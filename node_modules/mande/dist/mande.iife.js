/*!
  * mande v2.0.7
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
var Mande = (function (exports) {
  'use strict';

  function stringifyQuery(query) {
      let searchParams = Object.keys(query)
          .map((k) => [k, query[k]].map(encodeURIComponent).join('='))
          .join('&');
      return searchParams ? '?' + searchParams : '';
  }
  let leadingSlashRE = /^\/+/;
  function joinURL(base, url) {
      return (base +
          (url &&
              (base.endsWith('/')
                  ? url.replace(leadingSlashRE, '')
                  : url.startsWith('/')
                      ? url
                      : '/' + url)));
  }
  function removeNullishValues(headers) {
      return Object.keys(headers).reduce((newHeaders, headerName) => {
          if (headers[headerName] != null) {
              // @ts-ignore
              newHeaders[headerName] = headers[headerName];
          }
          return newHeaders;
      }, {});
  }
  /**
   * Global default options as {@link Options} that are applied to **all** mande
   * instances. Always contain an initialized `headers` property with the default
   * headers:
   * - Accept: 'application/json'
   * - 'Content-Type': 'application/json'
   */
  const defaults = {
      responseAs: 'json',
      headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
      },
      stringify: JSON.stringify,
  };
  /**
   * Create a Mande instance
   *
   * @example
   * ```js
   * const users = mande('/api/users')
   * users.get('2').then(user => {
   *   // do something
   * })
   * ```
   * @param baseURL - absolute url
   * @param instanceOptions - optional options that will be applied to every
   * other request for this instance
   */
  function mande(baseURL, passedInstanceOptions = {}, fetchPolyfill) {
      function _fetch(method, 
      // url can be any method, data for POST/PUT/PATCH, and options for all (without url or data)
      urlOrDataOrOptions, 
      // data for POST/PUT/PATCH, and options for all (without url or data)
      dataOrOptions, localOptions = {}) {
          let url;
          let data;
          // at least the URL was omitted, localOptions wasn't passed so we can safely override it
          // get(options) or put(data, options) or put(options)
          if (typeof urlOrDataOrOptions === 'object') {
              url = '';
              // if urlOrDataOrOptions is an object, it's either options or data
              // if dataOrOptions was passed, urlOrDataOrOptions is data
              localOptions = dataOrOptions || urlOrDataOrOptions || {};
              // if it's a POST/PUT/PATCH, dataOrOptions is data
              // if it's option, we will set data to options but it will be ignored later
              data = urlOrDataOrOptions;
          }
          else {
              // get(url) or get(url, options) or put(url, data) or put(url, data, options)
              url = urlOrDataOrOptions;
              data = dataOrOptions;
          }
          let mergedOptions = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaults), instanceOptions), { method }), localOptions), { 
              // we need to ditch nullish headers
              headers: removeNullishValues(Object.assign(Object.assign(Object.assign({}, defaults.headers), instanceOptions.headers), localOptions.headers)) });
          let query = Object.assign(Object.assign(Object.assign({}, defaults.query), instanceOptions.query), localOptions.query);
          let { responseAs } = mergedOptions;
          url = joinURL(baseURL, typeof url === 'number' ? '' + url : url || '');
          // TODO: warn about multiple queries provided not supported
          // if (__DEV__ && query && urlInstance.search)
          // TODO: use URL and URLSearchParams
          url += stringifyQuery(query);
          // only stringify body if it's a POST/PUT/PATCH, otherwise it could be the options object
          // it's not used by GET/DELETE but it would also be wasteful
          if (method[0] === 'P' && data && !mergedOptions.body) {
              mergedOptions.body =
                  data instanceof FormData ? data : mergedOptions.stringify(data);
          }
          // we check the localFetch here to account for global fetch polyfills and msw in tests
          const localFetch = typeof fetch != 'undefined' ? fetch : fetchPolyfill;
          if (!localFetch) {
              throw new Error('No fetch function exists. Make sure to include a polyfill on Node.js.');
          }
          return localFetch(url, mergedOptions)
              .then((response) => 
          // This is to get the response directly in the next then
          Promise.all([
              response,
              responseAs === 'response'
                  ? response
                  : // TODO: propagate error data to MandeError
                      response[responseAs]().catch(() => null),
          ]))
              .then(([response, dataOrError]) => {
              if (response.status >= 200 && response.status < 300) {
                  // data is a raw response when responseAs is response
                  return responseAs !== 'response' && response.status == 204
                      ? null
                      : dataOrError;
              }
              // Has better browser support and is way smaller than `class MandeError extends Error`
              let err = new Error(response.statusText);
              err.response = response;
              err.body = dataOrError;
              throw err;
          });
      }
      const instanceOptions = Object.assign({ query: {}, headers: {} }, passedInstanceOptions);
      return {
          options: instanceOptions,
          post: _fetch.bind(null, 'POST'),
          put: _fetch.bind(null, 'PUT'),
          patch: _fetch.bind(null, 'PATCH'),
          // these two have no body
          get: (url, options) => _fetch('GET', url, null, options),
          delete: (url, options) => _fetch('DELETE', url, null, options),
      };
  }
  /**
   * Creates an Nuxt 2 SSR compatible function that automatically proxies cookies to requests and works transparently on
   * the server and client (it still requires a fetch polyfill on Node). Note this is only needed if you need to proxy
   * cookies to the server.
   *
   * @example
   * ```js
   * import { mande, nuxtWrap } from 'mande'
   *
   * const fetchPolyfill = process.server ? require('node-fetch') : fetch
   * const users = mande(BASE_URL + '/api/users', {}, fetchPolyfill)
   *
   * export const getUserById = nuxtWrap(users, (api, id: string) => api.get(id))
   * ```
   *
   * @param api - Mande instance to wrap
   * @param fn - function to be wrapped
   */
  function nuxtWrap(api, fn) {
      // args for the api call + 1 because of api parameter
      const argsAmount = fn.length;
      const wrappedCall = function _wrappedCall() {
          let apiInstance = api;
          let args = Array.from(arguments);
          // call from nuxt server with a function to augment the api instance
          if (arguments.length === argsAmount) {
              apiInstance = Object.assign({}, api);
              // remove the first argument
              const [augmentApiInstance] = args.splice(0, 1);
              // let the caller augment the instance
              augmentApiInstance(apiInstance);
          }
          return fn.call(null, apiInstance, ...args);
      };
      return wrappedCall;
  }

  exports.defaults = defaults;
  exports.mande = mande;
  exports.nuxtWrap = nuxtWrap;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
